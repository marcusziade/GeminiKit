import Foundation

/// Represents content in a conversation with the Gemini API.
///
/// Content is the fundamental building block for interactions with Gemini models.
/// Each content instance has a role (user, model, or system) and contains one or more parts
/// that can include text, images, audio, video, function calls, and more.
///
/// ## Topics
///
/// ### Creating Content
///
/// - ``init(role:parts:)``
/// - ``user(_:)``
/// - ``model(_:)``
/// - ``system(_:)``
/// - ``user(_:)-8ktc9``
/// - ``model(_:)-5l7ux``
/// - ``function(response:)``
///
/// ### Properties
///
/// - ``role``
/// - ``parts``
///
/// ## Example
///
/// ```swift
/// // Simple text content
/// let userMessage = Content.user("Hello, Gemini!")
/// let systemPrompt = Content.system("You are a helpful assistant")
///
/// // Multi-modal content
/// let multiModal = Content(
///     role: .user,
///     parts: [
///         .text("What's in this image?"),
///         .inlineData(InlineData(mimeType: "image/jpeg", data: imageData))
///     ]
/// )
///
/// // Function response
/// let functionResult = Content.function(
///     response: FunctionResponse(
///         name: "get_weather",
///         response: ["temperature": 72, "condition": "sunny"]
///     )
/// )
/// ```
public struct Content: Codable, Equatable, Sendable {
    /// The role of the content creator.
    ///
    /// Indicates who created this content: the user, the model, or the system.
    /// System role is used for instructions that guide the model's behavior.
    public let role: Role
    
    /// The parts that make up the content.
    ///
    /// Each part represents a different type of content such as text, images,
    /// function calls, or other media. A single content can contain multiple
    /// parts of different types.
    public let parts: [Part]
    
    /// Creates a new content instance
    /// - Parameters:
    ///   - role: The role of the content creator
    ///   - parts: The parts that make up the content
    public init(role: Role, parts: [Part]) {
        self.role = role
        self.parts = parts
    }
    
    /// Creates user content with text
    /// - Parameter text: The text content
    /// - Returns: A content instance with user role
    public static func user(_ text: String) -> Content {
        Content(role: .user, parts: [.text(text)])
    }
    
    /// Creates model content with text
    /// - Parameter text: The text content
    /// - Returns: A content instance with model role
    public static func model(_ text: String) -> Content {
        Content(role: .model, parts: [.text(text)])
    }
    
    /// Creates system content with text
    /// - Parameter text: The text content
    /// - Returns: A content instance with system role
    public static func system(_ text: String) -> Content {
        Content(role: .system, parts: [.text(text)])
    }
}

/// The role of the content creator in a conversation.
///
/// Roles define who is speaking in the conversation and affect how the model
/// interprets and responds to the content.
///
/// ## Cases
///
/// - ``user``: Content from the end user
/// - ``model``: Content generated by the model
/// - ``system``: System instructions that guide model behavior
/// - ``function``: Results from function calls
public enum Role: String, Codable, Equatable, Sendable {
    case user
    case model
    case system
}

/// Represents a part of content that can be sent to or received from Gemini models.
///
/// Parts are the building blocks of content, allowing for rich multi-modal interactions
/// including text, images, audio, video, function calls, and more.
///
/// ## Topics
///
/// ### Text Content
///
/// - ``text(_:)``
/// - ``thinking(_:)``
///
/// ### Media Content
///
/// - ``inlineData(_:)``
/// - ``fileData(_:)``
///
/// ### Function Calling
///
/// - ``functionCall(_:)``
/// - ``functionResponse(_:)``
///
/// ### Code Execution
///
/// - ``codeExecutionResult(_:)``
/// - ``executableCode(_:)``
///
/// ## Example
///
/// ```swift
/// // Text part
/// let textPart = Part.text("Hello, world!")
///
/// // Image part
/// let imagePart = Part.inlineData(
///     InlineData(mimeType: "image/jpeg", data: imageData)
/// )
///
/// // Function call part
/// let functionPart = Part.functionCall(
///     FunctionCall(
///         name: "get_weather",
///         args: ["location": "Tokyo"]
///     )
/// )
/// ```
public enum Part: Codable, Equatable, Sendable {
    case text(String)
    case inlineData(InlineData)
    case fileData(FileData)
    case functionCall(FunctionCall)
    case functionResponse(FunctionResponse)
    case executableCode(ExecutableCode)
    case codeExecutionResult(CodeExecutionResult)
    case videoMetadata(VideoMetadata)
    
    enum CodingKeys: String, CodingKey {
        case text
        case inlineData
        case fileData
        case functionCall
        case functionResponse
        case executableCode
        case codeExecutionResult
        case videoMetadata
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if let text = try container.decodeIfPresent(String.self, forKey: .text) {
            self = .text(text)
        } else if let inlineData = try container.decodeIfPresent(InlineData.self, forKey: .inlineData) {
            self = .inlineData(inlineData)
        } else if let fileData = try container.decodeIfPresent(FileData.self, forKey: .fileData) {
            self = .fileData(fileData)
        } else if let functionCall = try container.decodeIfPresent(FunctionCall.self, forKey: .functionCall) {
            self = .functionCall(functionCall)
        } else if let functionResponse = try container.decodeIfPresent(FunctionResponse.self, forKey: .functionResponse) {
            self = .functionResponse(functionResponse)
        } else if let executableCode = try container.decodeIfPresent(ExecutableCode.self, forKey: .executableCode) {
            self = .executableCode(executableCode)
        } else if let codeExecutionResult = try container.decodeIfPresent(CodeExecutionResult.self, forKey: .codeExecutionResult) {
            self = .codeExecutionResult(codeExecutionResult)
        } else if let videoMetadata = try container.decodeIfPresent(VideoMetadata.self, forKey: .videoMetadata) {
            self = .videoMetadata(videoMetadata)
        } else {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Unknown part type")
            )
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .text(let text):
            try container.encode(text, forKey: .text)
        case .inlineData(let data):
            try container.encode(data, forKey: .inlineData)
        case .fileData(let data):
            try container.encode(data, forKey: .fileData)
        case .functionCall(let call):
            try container.encode(call, forKey: .functionCall)
        case .functionResponse(let response):
            try container.encode(response, forKey: .functionResponse)
        case .executableCode(let code):
            try container.encode(code, forKey: .executableCode)
        case .codeExecutionResult(let result):
            try container.encode(result, forKey: .codeExecutionResult)
        case .videoMetadata(let metadata):
            try container.encode(metadata, forKey: .videoMetadata)
        }
    }
}

/// Inline data content
public struct InlineData: Codable, Equatable, Sendable {
    /// The MIME type of the data
    public let mimeType: String
    
    /// The base64-encoded data
    public let data: String
    
    /// Creates a new inline data instance
    /// - Parameters:
    ///   - mimeType: The MIME type of the data
    ///   - data: The base64-encoded data
    public init(mimeType: String, data: String) {
        self.mimeType = mimeType
        self.data = data
    }
    
    /// Creates inline data from raw data
    /// - Parameters:
    ///   - mimeType: The MIME type of the data
    ///   - data: The raw data
    public init(mimeType: String, data: Data) {
        self.mimeType = mimeType
        self.data = data.base64EncodedString()
    }
}

/// File data reference
public struct FileData: Codable, Equatable, Sendable {
    /// The MIME type of the file
    public let mimeType: String
    
    /// The URI of the uploaded file
    public let fileUri: String
    
    /// Creates a new file data instance
    /// - Parameters:
    ///   - mimeType: The MIME type of the file
    ///   - fileUri: The URI of the uploaded file
    public init(mimeType: String, fileUri: String) {
        self.mimeType = mimeType
        self.fileUri = fileUri
    }
}

/// A function call made by the model
public struct FunctionCall: Codable, Equatable, Sendable {
    /// The name of the function to call
    public let name: String
    
    /// The arguments to pass to the function
    public let args: [String: AnyCodable]
    
    /// Creates a new function call
    /// - Parameters:
    ///   - name: The name of the function to call
    ///   - args: The arguments to pass to the function
    public init(name: String, args: [String: AnyCodable]) {
        self.name = name
        self.args = args
    }
}

/// A response from a function call
public struct FunctionResponse: Codable, Equatable, Sendable {
    /// The name of the function that was called
    public let name: String
    
    /// The response from the function
    public let response: [String: AnyCodable]
    
    /// Creates a new function response
    /// - Parameters:
    ///   - name: The name of the function that was called
    ///   - response: The response from the function
    public init(name: String, response: [String: AnyCodable]) {
        self.name = name
        self.response = response
    }
}

/// Executable code to be run
public struct ExecutableCode: Codable, Equatable, Sendable {
    /// The programming language
    public let language: Language
    
    /// The code to execute
    public let code: String
    
    /// Supported programming languages
    public enum Language: String, Codable, Equatable, Sendable {
        case python = "PYTHON"
    }
    
    /// Creates a new executable code instance
    /// - Parameters:
    ///   - language: The programming language
    ///   - code: The code to execute
    public init(language: Language, code: String) {
        self.language = language
        self.code = code
    }
}

/// Result of code execution
public struct CodeExecutionResult: Codable, Equatable, Sendable {
    /// The outcome of the execution
    public let outcome: String
    
    /// The output from the execution
    public let output: String
    
    /// Creates a new code execution result
    /// - Parameters:
    ///   - outcome: The outcome of the execution
    ///   - output: The output from the execution
    public init(outcome: String, output: String) {
        self.outcome = outcome
        self.output = output
    }
}

/// Video metadata for timing
public struct VideoMetadata: Codable, Equatable, Sendable {
    /// Start offset in the video
    public let startOffset: String?
    
    /// End offset in the video
    public let endOffset: String?
    
    /// Frames per second
    public let fps: Double?
    
    /// Creates a new video metadata instance
    /// - Parameters:
    ///   - startOffset: Start offset in the video
    ///   - endOffset: End offset in the video
    ///   - fps: Frames per second
    public init(startOffset: String? = nil, endOffset: String? = nil, fps: Double? = nil) {
        self.startOffset = startOffset
        self.endOffset = endOffset
        self.fps = fps
    }
}